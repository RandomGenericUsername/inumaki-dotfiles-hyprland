#!/bin/bash

: '
     __ __     ____           __        ____               __ __
  __/ // /_   /  _/___  _____/ /_____ _/ / /__  _____   __/ // /_
 /_  _  __/   / // __ \/ ___/ __/ __ `/ / / _ \/ ___/  /_  _  __/
/_  _  __/  _/ // / / (__  ) /_/ /_/ / / /  __/ /     /_  _  __/
 /_//_/    /___/_/ /_/____/\__/\__,_/_/_/\___/_/       /_//_/

'

# ------------------ Source relevant variables/constants and functions ------------------ #
SCRIPT_INVOCATION_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

lib_scripts="$SCRIPT_INVOCATION_DIR/src/.lib/export.sh"
configs="$SCRIPT_INVOCATION_DIR/src/.conf/export.sh"
settings="$SCRIPT_INVOCATION_DIR/settings"
variables_handler_scripts="$SCRIPT_INVOCATION_DIR/src/dotfiles-environment-template/{{cookiecutter.project_slug}}/.config/hypr/scripts/variables_handler.sh"
assets_dir="$SCRIPT_INVOCATION_DIR/src/assets"

# Settings needs to be sourced first because it contains definitions required by settings at config directory.
source "$settings" 
source "$configs"
source "$lib_scripts"
source "$variables_handler_scripts" 

# Required to update the log path variable in the print debug script
#export LOG;
# This is required so other scripts can use this utility using the temporal installation path.
export print_debug="/tmp/.print-debug/print-debug"
# --------------------------------------------------------------------------------------- #

# ------------------------------------ Setup ------------------------------------ #

# Clear the terminal for clearer output.
clear 
# Check if the current distro is supported and get the package manager. If not supported, exit.
get_package_manager
# Parse the comand line options.
parse_options "$@" 
# Pretty print the installer message.
pretty_print_installer_msg 
# Promp for proceeding with installation.
prompt_install 
# Print message to inform the user that dependencies are being installed.
echo "INFO: [Boostraping...]" 
# Install the print debug utility
install_print_debug_util "/tmp/.print-debug" # Install print debug utility
# Check if the current distro is based on Arch Linux and install yay if it is.
if_arch_based_distro
# Create file for logging the installation (if enabled)
create_log 
# Check for previous installation
check_previous_installation 
# Show the installation type to be performed
$print_debug "Performing '$INSTALL_TYPE' installation" 
# Install packages and utils required to run the installation tasks
install_packages_from_file "$BOOTSTRAP_DEPENDENCIES" 
$print_debug "Bootstraping finished." -t "success"
# --------------------------------------------------------------------------------------- #


# ------------------------------------ Install ------------------------------------ #


run_tasks() {

   $print_debug "Beginning installation..." -t "info"

   # These directories are going to be deleted
   for dir in \
      "$HOME/.config/wal" \
      "/tmp/wal"
   do
      delete_directory "$dir" --yes || [ $? -gt 1 ] && exit $?
   done


   create_dirs \
    "$HOME/.cache" \
    "$HOME/.config/wal" \
    "$INSTALL_PATH" \
    "$WALLPAPERS_DIRECTORY" \
    "$GENERATED_WALLPAPERS_WITH_EFFECTS_DIR" \
   || exit $?

   install_packages_from_file \
      "$INSTALLATION_DEPENDENCIES.$BASE_DISTRO" \
   || exit $?

   install_argument_parser_util "$ARGUMENT_PARSER_UTIL_PATH" || exit $?
   install_print_debug_util "$PRINT_DEBUG_UTIL_PATH" || exit $?

   install_pyenv "$DOTFILES_INSTALL_PATH/.pyenv" || exit $?
   install_python_version "$DOTFILES_INSTALL_PATH/.pyenv" "$PYTHON_VERSION" || exit $?
   create_python_venv "$DOTFILES_INSTALL_PATH/.pyenv/versions/$PYTHON_VERSION/bin/python" "$PYTHON_VENV" || exit $?
   install_packages_in_venv "$PIP_PACKAGES" "$PYTHON_VENV" || exit $?
   
   install_nvm "$DOTFILES_INSTALL_PATH/.nvm" || exit $?
   install_node_version "$DOTFILES_INSTALL_PATH/.nvm" "$NODEJS_VERSION" || exit $?

   install_oh_my_zsh "$DOTFILES_INSTALL_PATH/.oh-my-zsh" || exit $?

   get_env_vars "$settings" \
      "$INSTALLATION_SETTINGS" \
      "$INSTALLATION_DEFAULTS" \
      "$INSTALLATION_ENVIRONMENT_VARIABLES" \
      "$INSTALLATION_FILESYSTEM_MAPPING" \
      "$INSTALL_PATH/environment_variables.sh" \
   || exit $?
   
   create_cookiecutter_project \
      -e "$INSTALL_PATH/environment_variables.sh" \
      -t "$SCRIPT_INVOCATION_DIR/src/dotfiles-environment-template" \
      -p "$PYTHON_VENV" \
      -i "$INSTALL_PATH" \
   || exit $?


   # Temporary move wal files to avoid conflicts with the symbolic link
   mkdir -p "/tmp/wal" || exit $?
   mv "$DOTFILES_INSTALL_PATH/.config/wal/"* "/tmp/wal/" || exit $?

   create_symbolic_link "$DOTFILES_INSTALL_PATH/.cache" --source "$HOME/.cache" --target "$DOTFILES_INSTALL_PATH" || exit $?
   create_symbolic_link "$WALLPAPERS_DIR" --source "$WALLPAPERS_DIRECTORY" --target "$DOTFILES_INSTALL_PATH" || exit $?
   create_symbolic_link "$DOTFILES_INSTALL_PATH/.config/wal" --source "$HOME/.config/wal" --target "$DOTFILES_INSTALL_PATH/.config" || exit $?

   # Move wal files back
   mv "/tmp/wal/"* "$DOTFILES_INSTALL_PATH/.config/wal/" || exit $?
   rm -rf "/tmp/wal" || exit $?


   echo "" >  "$DOTFILES_METADATA" || exit $?
   # Enable services
   # Enable bluetooth service
   #sudo systemctl enable --now bluetooth
   cp "$assets_dir/default_wallpaper/default.png" "$WALLPAPERS_DIR/default.png" || exit $?

   tomlq ".wallpaper.current.path = \"$WALLPAPERS_DIR/default.png\"" "$DOTFILES_METADATA" --toml-output > "$DOTFILES_METADATA.tmp" && mv "$DOTFILES_METADATA.tmp" "$DOTFILES_METADATA" || exit $?
   tomlq ".wallpaper.current.name = \"default\"" "$DOTFILES_METADATA" --toml-output > "$DOTFILES_METADATA.tmp" && mv "$DOTFILES_METADATA.tmp" "$DOTFILES_METADATA" || exit $?

   tomlq ".wallpaper.effect.current.path = \"\"" "$DOTFILES_METADATA" --toml-output > "$DOTFILES_METADATA.tmp" && mv "$DOTFILES_METADATA.tmp" "$DOTFILES_METADATA" || exit $?
   tomlq ".wallpaper.effect.current.name = \"\"" "$DOTFILES_METADATA" --toml-output > "$DOTFILES_METADATA.tmp" && mv "$DOTFILES_METADATA.tmp" "$DOTFILES_METADATA" || exit $?


   $print_debug "Installation finished!!!" -t "info"
   if [ "$ENABLE_LOG" == "true" ] && [ "$ENABLE_DEBUG" == "true" ]; then
      $print_debug "Installation log generated at '$LOG'."
   fi
}

if [ "$ENABLE_DEBUG" = true ]; then
   # In debug mode, run_tasks directly with a simple spinner
   gum spin --spinner dot --title "Installing all packages and tools..." -- sleep 1 && run_tasks
else
   # In non-debug mode, run_tasks is executed in a subshell with gum spin
   # We need to ensure all environment variables and function definitions are passed to the subshell.
   # The command below:
   # - `declare -f` captures all function definitions (e.g., run_tasks and any helper functions)
   # - `declare -p` captures all environment variables in an exportable format
   # - `$(declare -f); $(declare -p); run_tasks` combines both function definitions and environment variables
   #   and executes them in the new subshell created by `gum spin`.
   if ! gum spin --spinner dot --title "Installing all packages and tools..." -- bash -c "$(declare -f); $(declare -p); run_tasks"; then
      # If any error occurs during the installation, print an error message with exit code
      printf "%b" "${ERROR_COLOR}" 
      echo "!!! An error occurred during installation: $?. Try running again the installation in debug mode with the '-d' or '--debug' options. !!!"
      printf "%b" "${NO_COLOR}" 
      exit 1
   fi
fi

$print_debug "You can now use dotfiles" -t "success"
# --------------------------------------------------------------------------------------- #


